<?php

declare(strict_types=1);

namespace Fpp;

final class Dumper
{
    public function dump(DefinitionCollection $collection): string
    {
        $code = <<<CODE
<?php
// this file is auto-generated by prolic/fpp
// don't edit this file manually

declare(strict_types=1);


CODE;
        foreach ($collection->definitions() as $definition) {
            /* @var Definition $definition */
            switch (ucfirst((string) $definition->type())) {
                case Data::VALUE:
                    $code .= $this->dumpData($definition);
                    break;
                case Enum::VALUE:
                    $code .= $this->dumpEnum($definition);
                    break;
                case AggregateChanged::VALUE:
                    $code .= $this->dumpAggregateChanged($definition);
                    break;
                case Command::VALUE:
                    $code .= $this->dumpCommand($definition);
                    break;
                case DomainEvent::VALUE:
                    $code .= $this->dumpEvent($definition);
                    break;
                case Query::VALUE:
                    $code .= $this->dumpCommand($definition);
                    break;
            }
        }

        return substr($code, 0, -1);
    }

    private function dumpData(Definition $definition): string
    {
        $dataClass = $this->generateDataClass($definition);
        $constructor = $this->generateFunctionalConstructor($definition);
        $accessors = $this->generateFunctionalAccessors($definition);
        $setters = $this->generateFunctionalSetters($definition);
        $functions = $this->generateFunctionNamespace($definition, $constructor . $accessors . $setters);

        return $dataClass . $functions;
    }

    private function dumpEnum(Definition $definition): string
    {
        $dataClass = $this->generateEnumClasses($definition);
        $constructors = $this->generateFunctionalEnumConstructors($definition);
        $functions = $this->generateFunctionNamespace($definition, $constructors);

        return $dataClass . $functions;
    }

    private function dumpAggregateChanged(Definition $definition): string
    {
        $dataClass = $this->generateAggregateChangedClass($definition);
        $constructor = $this->generateFunctionalConstructor($definition);
        $functions = $this->generateFunctionNamespace($definition, $constructor);

        return $dataClass . $functions;
    }

    private function dumpCommand(Definition $definition): string
    {
        $dataClass = $this->generateCommandClass($definition);
        $constructor = $this->generateFunctionalConstructor($definition);
        $functions = $this->generateFunctionNamespace($definition, $constructor);

        return $dataClass . $functions;
    }

    private function dumpEvent(Definition $definition): string
    {
        $dataClass = $this->generateEventClass($definition);
        $constructor = $this->generateFunctionalConstructor($definition);
        $functions = $this->generateFunctionNamespace($definition, $constructor);

        return $dataClass . $functions;
    }

    private function dumpQuery(Definition $definition): string
    {
        $dataClass = $this->generateQueryClass($definition);
        $constructor = $this->generateFunctionalConstructor($definition);
        $functions = $this->generateFunctionNamespace($definition, $constructor);

        return $dataClass . $functions;
    }

    private function generateDataClass(Definition $definition): string
    {
        $code = '';
        $indent = '';

        if ($definition->namespace() !== '') {
            $code = "namespace {$definition->namespace()} {\n    ";
            $indent = '    ';
        }

        $code .= "final class {$definition->name()}\n$indent{\n";

        foreach ($definition->arguments() as $argument) {
            $code .= "$indent    private \${$argument->name()};\n";
        }

        if (! empty($definition->arguments())) {
            $code .= "\n";
        }

        $code .= "$indent    public function __construct(";

        foreach ($definition->arguments() as $argument) {
            $code .= "{$argument->typehint()} \${$argument->name()}, ";
        }

        if (! empty($definition->arguments())) {
            $code = substr($code, 0, -2);
        }

        $code .= ")\n$indent    {\n";

        foreach ($definition->arguments() as $argument) {
            $code .= "$indent        \$this->{$argument->name()} = \${$argument->name()};\n";
        }

        $code .= "$indent    }\n";

        foreach ($definition->derivings() as $deriving) {
            switch ($deriving) {
                case (new Show())->value():
                    break;
                case (new StringConverter())->value():
                    $argument = current($definition->arguments());
                    $code .= <<<CODE
    
$indent    public function __toString(): string
$indent    {
$indent        return (string) \$this->{$argument->name()};
$indent    }

CODE;

                    break;
                case (new ArrayConverter())->value():
                    $code .= <<<CODE
    
$indent    public function toArray(): array
$indent    {
$indent        return [

CODE;

                    foreach ($definition->arguments() as $argument) {
                        $code .= "$indent            '{$argument->name()}' => \$this->{$argument->name()},\n";
                    }

                    $code .= <<<CODE
$indent        ];
$indent    }

$indent    public static function fromArray(array \$data): {$definition->name()}
$indent    {

CODE;
                    $constructorParams = '';
                    foreach ($definition->arguments() as $argument) {
                        $code .= <<<CODE
$indent        if (!isset(\$data['{$argument->name()}'])) {
$indent            throw new \InvalidArgumentException(
$indent                'Key {$argument->name()} is missing in \$data'
$indent            );
$indent        }
    

CODE;
                        $constructorParams .= '$data[\'' . $argument->name() . '\'], ';
                    }

                    $code .= "$indent        return new {$definition->name()}("
                        . substr($constructorParams, 0, -2)
                        . ");\n$indent    }\n";
                    break;
                case (new ValueObject())->value():
                    $fqcn = '\\' . $definition->name();

                    if ('' !== $definition->namespace()) {
                        $fqcn = '\\' . $definition->namespace() . $fqcn;
                    }

                    $code .= <<<CODE
    
$indent    public function sameAs($fqcn \$other): bool
$indent    {
$indent        return 
CODE;

                    foreach ($definition->arguments() as $argument) {
                        $code .= "\$this->{$argument->name()} === \$other->{$argument->name()}\n$indent            && ";
                    }


                    $code = substr($code, 0, -(strlen($indent) + 16)) . ";\n$indent    }\n";

                    break;
            }
        }

        $code .= "$indent}";

        if ($definition->namespace() !== '') {
            $code .= "\n}";
        }

        $code .= "\n\n";

        return $code;
    }

    private function generateEnumClasses(Definition $definition): string
    {
        $code = '';
        $indent = '';

        if ($definition->namespace() !== '') {
            $code = "namespace {$definition->namespace()} {\n    ";
            $indent = '    ';
        }

        $code .= "abstract class {$definition->name()}\n$indent{\n";
        $code .= "$indent    const OPTIONS = [\n";

        foreach ($definition->arguments() as $argument) {
            $code .= "$indent        {$argument->name()}::class,\n";
        }

        $code .= <<<CODE
$indent    ];

$indent    const OPTION_VALUES = [

CODE;

        foreach ($definition->arguments() as $argument) {
            $code .= "$indent        '{$argument->name()}',\n";
        }

        $code .= <<<CODE
$indent    ];

$indent    final public function __construct()
$indent    {
$indent        \$valid = false;

$indent        foreach(self::OPTIONS as \$value) {
$indent            if (\$this instanceof \$value) {
$indent                \$valid = true;
$indent                break;
$indent            }
$indent        }

$indent        if (! \$valid) {
$indent            \$self = get_class(\$this);
$indent            throw new \LogicException("Invalid {$definition->name()} '\$self' given");
$indent        }
$indent    }

$indent    public function sameAs({$definition->name()} \$other): bool
$indent    {
$indent        return get_class(\$this) === get_class(\$other);
$indent    }

$indent    public function __toString(): string
$indent    {
$indent        return static::VALUE;
$indent    }
$indent}

CODE;

        foreach ($definition->arguments() as $argument) {
            $code .= "\n$indent" . <<<CODE
final class {$argument->name()} extends {$definition->name()}
$indent{
$indent    const VALUE = '{$argument->name()}';
$indent}

CODE;
        }

        if ($definition->namespace() !== '') {
            $code .= "}\n";
        }

        $code .= "\n";

        return $code;
    }

    private function generateAggregateChangedClass(Definition $definition): string
    {
        $code = '';
        $indent = '';

        $messageName = $definition->messageName();

        if (null === $messageName) {
            $messageName = '\\' . $definition->name();
        }

        if ($definition->namespace() !== '') {
            $code = "namespace {$definition->namespace()} {\n    ";
            $indent = '    ';

            if (null == $definition->messageName()) {
                $messageName = '\\' . $definition->namespace() . $messageName;
            }
        }

        $code .= <<<CODE
final class {$definition->name()} extends \Prooph\EventSourcing\AggregateChanged
$indent{
$indent    protected \$messageName = '$messageName';

CODE;

        foreach ($definition->arguments() as $argument) {
            $code .= "$indent    private \${$argument->name()};\n";
        }

        $code .= "\n$indent    public static function withData(";

        foreach ($definition->arguments() as $argument) {
            $code .= "{$argument->typehint()} \${$argument->name()}, ";
        }

        if (! empty($definition->arguments())) {
            $code = substr($code, 0, -2);
        }

        $it = new \ArrayIterator($definition->arguments());
        $firstArgument = $it->current();

        $code .= ")\n$indent    {\n$indent        ";
        $code .= "\$event = self::occur(\${$firstArgument->name()}, [\n";

        $it->next();
        while ($it->valid()) {
            $argument = $it->current();
            $code .= "$indent            '{$argument->name()}' => \${$argument->name()},\n";
            $it->next();
        }

        $code .= "$indent        ]);\n\n";

        foreach ($definition->arguments() as $argument) {
            $code .= "$indent        \$event->{$argument->name()} = \${$argument->name()};\n";
        }

        $code .= "\n$indent        return \$event;\n$indent    }\n\n";

        foreach ($definition->arguments() as $argument) {
            $returnType = $argument->typehint() !== null
                ? ": {$argument->typehint()}"
                : '';

            $code .= <<<CODE
$indent    public function {$argument->name()}()$returnType
$indent    {
$indent        if (! isset(\$this->{$argument->name()})) {
$indent            \$this->{$argument->name()} = \$this->payload['{$argument->name()}'];
$indent        }

$indent        return \$this->{$argument->name()};
$indent    }


CODE;
        }

        $code = substr($code, 0, -1);
        $code .= "$indent}";

        if ($definition->namespace() !== '') {
            $code .= "\n}";
        }

        $code .= "\n\n";

        return $code;
    }

    private function generateCommandClass(Definition $definition): string
    {
        $code = '';
        $indent = '';

        $messageName = $definition->messageName();

        if (null === $messageName) {
            $messageName = '\\' . $definition->name();
        }

        if ($definition->namespace() !== '') {
            $code = "namespace {$definition->namespace()} {\n    ";
            $indent = '    ';

            if (null == $definition->messageName()) {
                $messageName = '\\' . $definition->namespace() . $messageName;
            }
        }

        $code .= <<<CODE
final class {$definition->name()} extends \Prooph\Common\Messaging\Command implements \Prooph\Common\Messaging\PayloadConstructable
$indent{\n$indent    use \Prooph\Common\Messaging\PayloadTrait;

$indent    protected \$messageName = '$messageName';

$indent    public function __construct(
CODE;

        foreach ($definition->arguments() as $argument) {
            $code .= "{$argument->typehint()} \${$argument->name()}, ";
        }

        if (! empty($definition->arguments())) {
            $code = substr($code, 0, -2);
        }

        $code .= ")\n$indent    {\n";

        $code .= "$indent        parent::__construct([\n";
        foreach ($definition->arguments() as $argument) {
            $code .= "$indent            '{$argument->name()}' => \${$argument->name()},\n";
        }
        $code .= "$indent        ]);\n";

        $code .= "$indent    }\n\n";

        foreach ($definition->arguments() as $argument) {
            $returnType = $argument->typehint() !== null
                ? ": {$argument->typehint()}"
                : '';

            $code .= <<<CODE
$indent    public function {$argument->name()}()$returnType
$indent    {
$indent        return \$this->payload['{$argument->name()}'];
$indent    }


CODE;
        }

        $code = substr($code, 0, -1);
        $code .= "$indent}";

        if ($definition->namespace() !== '') {
            $code .= "\n}";
        }

        $code .= "\n\n";

        return $code;
    }

    private function generateEventClass(Definition $definition): string
    {
        $code = '';
        $indent = '';

        $messageName = $definition->messageName();

        if (null === $messageName) {
            $messageName = '\\' . $definition->name();
        }

        if ($definition->namespace() !== '') {
            $code = "namespace {$definition->namespace()} {\n    ";
            $indent = '    ';

            if (null == $definition->messageName()) {
                $messageName = '\\' . $definition->namespace() . $messageName;
            }
        }

        $code .= <<<CODE
final class {$definition->name()} extends \Prooph\Common\Messaging\DomainEvent implements \Prooph\Common\Messaging\PayloadConstructable
$indent{\n$indent    use \Prooph\Common\Messaging\PayloadTrait;

$indent    protected \$messageName = '$messageName';

CODE;

        foreach ($definition->arguments() as $argument) {
            $code .= "$indent    private \${$argument->name()};\n";
        }

        $code .= "\n$indent    public function __construct(";

        foreach ($definition->arguments() as $argument) {
            $code .= "{$argument->typehint()} \${$argument->name()}, ";
        }

        if (! empty($definition->arguments())) {
            $code = substr($code, 0, -2);
        }

        $code .= ")\n$indent    {\n";

        $code .= "$indent        parent::__construct([\n";
        foreach ($definition->arguments() as $argument) {
            $code .= "$indent            '{$argument->name()}' => \${$argument->name()},\n";
        }
        $code .= "$indent        ]);\n";

        foreach ($definition->arguments() as $argument) {
            $code .= "$indent        \$this->{$argument->name()} = \${$argument->name()};\n";
        }

        $code .= "$indent    }\n\n";

        foreach ($definition->arguments() as $argument) {
            $returnType = $argument->typehint() !== null
                ? ": {$argument->typehint()}"
                : '';

            $code .= <<<CODE
$indent    public function {$argument->name()}()$returnType
$indent    {
$indent        if (! isset(\$this->{$argument->name()})) {
$indent            \$this->{$argument->name()} = \$this->payload['{$argument->name()}'];
$indent        }

$indent        return \$this->{$argument->name()};
$indent    }


CODE;
        }

        $code = substr($code, 0, -1);
        $code .= "$indent}";

        if ($definition->namespace() !== '') {
            $code .= "\n}";
        }

        $code .= "\n\n";

        return $code;
    }

    private function generateQueryClass(Definition $definition): string
    {
        $code = '';
        $indent = '';

        $messageName = $definition->messageName();

        if (null === $messageName) {
            $messageName = '\\' . $definition->name();
        }

        if ($definition->namespace() !== '') {
            $code = "namespace {$definition->namespace()} {\n    ";
            $indent = '    ';

            if (null == $definition->messageName()) {
                $messageName = '\\' . $definition->namespace() . $messageName;
            }
        }

        $code .= <<<CODE
final class {$definition->name()} extends \Prooph\Common\Messaging\Query implements \Prooph\Common\Messaging\PayloadConstructable
$indent{\n$indent    use \Prooph\Common\Messaging\PayloadTrait;

$indent    protected \$messageName = '$messageName';

$indent    public function __construct(
CODE;

        foreach ($definition->arguments() as $argument) {
            $code .= "{$argument->typehint()} \${$argument->name()}, ";
        }

        if (! empty($definition->arguments())) {
            $code = substr($code, 0, -2);
        }

        $code .= ")\n$indent    {\n";

        $code .= "$indent        parent::__construct([\n";
        foreach ($definition->arguments() as $argument) {
            $code .= "$indent            '{$argument->name()}' => \${$argument->name()},\n";
        }
        $code .= "$indent        ]);\n";

        $code .= "$indent    }\n\n";

        foreach ($definition->arguments() as $argument) {
            $returnType = $argument->typehint() !== null
                ? ": {$argument->typehint()}"
                : '';

            $code .= <<<CODE
$indent    public function {$argument->name()}()$returnType
$indent    {
$indent        return \$this->payload['{$argument->name()}'];
$indent    }


CODE;
        }

        $code = substr($code, 0, -1);
        $code .= "$indent}";

        if ($definition->namespace() !== '') {
            $code .= "\n}";
        }

        $code .= "\n\n";

        return $code;
    }

    private function generateFunctionalConstructor(Definition $definition): string
    {
        $type = $definition->namespace() !== ''
            ? '\\' . $definition->namespace() . '\\' . $definition->name()
            : '\\' . $definition->name();

        $code = "    const {$definition->name()} = '\\";
        $code .= "{$definition->namespace()}";

        if ($definition->namespace() !== '') {
            $code .= '\\' . "{$definition->name()}';\n\n";
        }

        $code .= "    function {$definition->name()}(";

        foreach ($definition->arguments() as $argument) {
            if (null !== $argument->typehint()) {
                $code .= "{$argument->typehint()} ";
            }

            $code.= "\${$argument->name()}, ";
        }

        if (! empty($definition->arguments())) {
            $code = substr($code, 0, -2);
        }

        $code .= "): $type ";
        $code .= "{\n        return new $type(";

        foreach ($definition->arguments() as $argument) {
            $code.= "\${$argument->name()}, ";
        }

        if (! empty($definition->arguments())) {
            $code = substr($code, 0, -2);
        }

        $code .= ");\n    }\n\n";

        return $code;
    }

    private function generateFunctionalEnumConstructors(Definition $definition): string
    {
        $prefix = $definition->namespace() !== ''
            ? '\\' . $definition->namespace() . '\\'
            : '\\';

        $code = "";
        foreach ($definition->arguments() as $argument) {
            $code .= "    const {$argument->name()} = '$prefix{$definition->name()}\\";
            $code .= <<<CODE
{$argument->name()}';

    function {$argument->name()}()
    {
        return new $prefix{$argument->name()}();
    }


CODE;
        }

        return $code;
    }

    private function generateFunctionalAccessors(Definition $definition): string
    {
        $type = $definition->namespace() !== ''
            ? '\\' . $definition->namespace() . '\\' . $definition->name()
            : '\\' . $definition->name();

        $code = '';

        foreach ($definition->arguments() as $position => $argument) {
            $param = '$' . lcfirst($definition->name());

            $code .= "    const {$argument->name()} = '\\";
            $code .= "{$definition->namespace()}";

            if ($definition->namespace() !== '') {
                $code .= '\\' . "{$definition->name()}\\";
            }

            $code .= $argument->name() . "';\n\n";
            $code .= <<<CODE
    function {$argument->name()}($type $param): {$argument->typehint()} {
        \$f = \Closure::bind(
            function ($type $param): {$argument->typehint()} {
                return $param->{$argument->name()};
            },
            null,
            $param
        );
    
        return \$f($param);
    }
    

CODE;
        }

        return $code;
    }

    private function generateFunctionalSetters(Definition $definition): string
    {
        $type = $definition->namespace() !== ''
            ? '\\' . $definition->namespace() . '\\' . $definition->name()
            : '\\' . $definition->name();

        $code = '';

        foreach ($definition->arguments() as $position => $argument) {
            $functionName = 'set' . ucfirst($argument->name());
            $param = '$' . lcfirst($definition->name());
            $code .= "    const $functionName = '\\";
            $code .= "{$definition->namespace()}";

            if ($definition->namespace() !== '') {
                $code .= '\\' . "{$definition->name()}\\";
            }

            $code .= $functionName . "';\n\n";
            $code .= <<<CODE
    function $functionName($type $param, {$argument->typehint()} \${$argument->name()}): $type {
        \$f = \Closure::bind(
            function ($type $param, \$value) {
                return $param->{\$value};
            },
            null,
            $param
        );
    
        return new $type(
CODE;

            foreach ($definition->arguments() as $innerPosition => $innerArgument) {
                if ($innerPosition === $position) {
                    $code .= "\${$innerArgument->name()}, ";
                } else {
                    $code .= "\$f($param, '{$innerArgument->name()}'), ";
                }
            }

            $code = substr($code, 0, -2) . ");\n    }\n\n";
        }

        return $code;
    }

    private function generateFunctionNamespace(Definition $definition, string $content)
    {
        $code = "namespace {$definition->namespace()}";

        if ($definition->namespace() !== '') {
            $code .= '\\';
        }

        return substr("$code{$definition->name()} {\n$content", 0, -1) . "}\n\n";
    }
}
